/*
    A GNTP implementation for Node.js
*/
// We'll be emitting some events..
var EventEmitter = require('events').EventEmiter;

// Protocol
var Protocol = Object.freeze({ name : "GNTP", version : "1.0"});
var EndLine = "\r\n";

// emulate Enums for switching purposes.
var RequestTypeEnum = Object.freeze({ UNKNOWN : "UNKNOWN", REGISTER : "REGISTER", NOTIFY : "NOTIFY", SUBSCRIBE : "SUBSCRIBE", POLL : "POLL" });
var ResponseTypeEnum = Object.freeze({ UNKNOWN : "UNKNOWN", OK : "OK", CALLBACK : "CALLBACK", ERROR : "ERROR" });

/*-------------------------------
    Hash - support
    sourced: view-source:http://rick.measham.id.au/javascript/hash.htm
    Copyright Rick Measham, 2006. All rights reserved.
    This library is free software; you can redistribute it and/or modify it under the GPL or under the same terms as Perl at your discresion.
*/
function Hash(){
    for( var i=0; i < arguments.length; i++ )
        for( n in arguments[i] )
            if( arguments[i].hasOwnProperty(n) )
                this[n] = arguments[i][n];
}

// Hash.version = 1.00;	// Original version
// Hash.version = 1.01;	// Added ability to initialize in the constructor
// Hash.version = 1.02;	// Fixed document bug that showed a non-working example (thanks mareks)
//Hash.version = 1.03;	// Removed returning this from the constructor (thanks em-dash)
Hash.version = 1.04;	// Missed some 'var' declarations (thanks Twey)

Hash.prototype = {};

Hash.prototype.keys = function(){
    var rv = [];
    for( var n in this )
        if( this.hasOwnProperty(n) )
            rv.push(n);
    return rv;
};

Hash.prototype.length = function(){
    return this.keys().length();
};

Hash.prototype.values = function(){
    var rv = [];
    for( var n in this )
        if( this.hasOwnProperty(n) )
            rv.push(this[n]);
    return rv;
};

Hash.prototype.slice = function(){
    var rv = [];
    for( var i = 0; i < arguments.length; i++ )
        rv.push(( this.hasOwnProperty( arguments[i] ) ) ? this[arguments[i]] : undefined );
    return rv;
};

Hash.prototype.concat = function(){
    for( var i = 0; i < arguments.length; i++ )
        for( var n in arguments[i] )
            if( arguments[i].hasOwnProperty(n) )
                this[n] = arguments[i][n];
    return this;
};
/* --- END Hash -- */

/*-------------------------------
    Header object/class
    Implementation of all the valid headers for the GNTP protocol
    as of 1.0
*/
var HeaderEnum = Object.freeze({
   applicationIcon : 'Application-Icon',
   applicationName : 'Application-Name',
   trueValue : 'True',
   falseValue : 'False',
   customHeaderPrefix : 'X-',
   dataHeaderPrefix : 'Data-',
   errorCode : 'Error-Code',
   errorDescription : 'Error-Description',
   growlResourcePointerPrefix : 'x-growl-resource://',
   notificationCallbackContext : 'Notification-Callback-Context',
   notificationCallbackContextType : 'Notification-Callback-Context-Type',
   notificationCallbackResult : 'Notification-Callback-Result',
   notificationCallbackTarget : 'Notification-Callback-Target',
   notificationCoalescingId : 'Notification-Coalescing-ID',
   notificationDisplayName : 'Notification-Display-Name',
   notificationEnabled : 'Notification-Enabled',
   notificationIcon : 'Notification-Icon',
   notificationId : 'Notification-Id',
   notificationName : 'Notification-Name',
   notificationPriority : 'Notification-Priority',
   notificationSticky : 'Notification-Sticky',
   notificationText : 'Notification-Text',
   notificationTitle : 'Notification-Title',
   notificationsCount : 'Notifications-Count',
   originMachineName : 'Origin-Machine-Name',
   originPlatformName : 'Origin-Platform-Version',
   originPlatformVersion : 'Origin-Platform-Name',
   originSoftwareName : 'Origin-Software-Name',
   originSoftwareVersion : 'Origin-Software-Version',
   recieved : 'Recieved',
   resourceIdentifier : 'Identifier',
   resourceLength : 'Length',
   subscriberId : 'Subscriber-ID',
   subscriberName : 'Subscriber-Name',
   subscriberPort : 'Subscriber-Port',
   subscriberTtl : 'Subscriber-TTL'
});

var HeaderBlankCount=0;

function Header(){
    this.name = null; //string
    this.value = null; // string
    this.growlResource = null; // string
    this.growlResourcePointerID = null; // string
    
    this.isBlank = false; // bool
    this.isCustom = false; // bool
    this.isData = false; // bool
    this.isGrowlResourcePointer = false; // bool
    this.isResourceIdentifier = false; // bool
    this.isValid = false; // bool
}
exports.Header = Header;

Header.prototype.init = function (name,value) {
    this.name = name;
    this.value = value;
    this.isValid = true;
    
    this.isBlank = (name == null && value == null);
    if( !this.isBlank ){
        if( value != null ){ 
            if( value.toString().indexOf(HeaderEnum.growlResourcePointerPrefix) == 0){ this.isGrowlResourcePointer = true;}
        }
        if( name != null && name == HeaderEnum.resourceIdentifier ) this.isResourceIdentifier = true;
        if( name != null && name.indexOf(HeaderEnum.customHeaderPrefix) == 0 ) this.isCustomHeader = true;
		if( name != null && name.indexOf(HeaderEnum.dataHeaderPrefix) == 0 ) this.isDataHeader = true;
    }else{
        this.name = "blank-header-" + HeaderBlankCount;
        HeaderBlankCount++;
    }
};

Header.prototype.blank = function () {
    return this.stringValue(null,null);
};

Header.prototype.stringValue = function (name,value) {
    var head = new Header();
    head.init(name,value);
    return head;
};

Header.prototype.boolValue = function (name,value) {
    var head = new Header();
    if( value == true ){
        head.init(name,HeaderEnum.trueValue);
    }else{
        head.init(name,HeaderEnum.falseValue);
    }
    return head;
};

Header.prototype.resourceValue = function (name,value) {
    var head = null;
    if( value != null ){
        head = new Header();
        head.init(name,value);
        // here we're going to need to figure out the Resource handling.
    }
    return head;
};

/*-------------------------------------
    Headers object/class
    Headers is an order collection of Header objects.
    This handles controlling the output in the correct order
    so that the user of the objects doesn't have to.
*/
function Headers() {
    // collections
    this.headers = [];
    this.customHeaders = [];
    this.dataHeaders = [];
    this.pointerHeaders = [];
    // this will be used for by name, only for checking existance.
    this.allHeaders = new Hash();
}
exports.Headers = Headers;

Headers.prototype.addHeader = function (header) {
    if( header != null ){
        if( header.isValid == true){
            var ht = 0;
            if( header.isGrowlResourcePointer ){
                this.pointerHeaders.push(header);
                ht = 3;
            }else if( header.isCustomHeader ){
                this.customHeaders.push(header);
                ht = 2;
            }else if( header.isDataHeader ){
                this.dataHeaders.push(header);
                ht = 1;
            }else{
                this.headers.push(header);
            }
            this.allHeaders[header.name] = ht;
        }
    }
};

Headers.prototype.addHeaders = function (headers) {
    var i;
    for( i in headers.headers ) this.addHeader(headers.headers[i]);
    for( i in headers.customHeaders ) this.addHeader(headers.customHeaders[i]);
    for( i in headers.dataHeaders ) this.addHeader(headers.dataHeaders[i]);
    for( i in headers.pointerHeaders ) this.addHeader(headers.pointerHeaders[i]);
};

Headers.prototype.getHeader = function (name) {
    var head = Header.blank();
    var ht = this.allHeaders[name];
    if( ht != null ){
        var hl;
        switch( ht ){
            case 0:
                hl = this.headers;
                break;
            case 1:
                hl = this.customHeaders;
                break;
            case 2:
                hl = this.dataHeaders;
                break;
            case 3:
                hl = this.pointerHeaders;
                break;
        }
        for( var i in hl){
            if( i.name == name ){
                head = i;
                break;
            }
        }
    }
    return head;
};

/*------------------------------
    Application object/class
    Describes and application in the form of
*/
function Application (name) {
    this.name = name || 'node-gntp'; // String
    this.icon = null; // Resource
    
}
exports.Application = Application;

Application.prototype.toHeaders = function () {
    var headers = new Headers();
    var header = new Header();
    headers.addHeader(header.stringValue(HeaderEnum.applicationName,this.name));
    if( this.icon != null ){
        headers.addHeader(header.resourceValue(HeaderEnum.applicationIcon,this.icon));
        // this is where we would associate binary data ... if we supported it
    }
    return headers;
}
// why is $this empty in this function!!
Application.prototype.toRequest = function () {
    var req = new ApplicationRequest(this);
    return req;
}


/*------------------------------
    ApplicationRequest object/class
    Defines the content of REGISTER message
*/
function ApplicationRequest (application) {
    this.type = RequestTypeEnum.REGISTER; // RequestType
    this.application = null; // Application
    this.notifications = [];
    
    if( application != null ){
        this.application = application;
    }
}
exports.ApplicationRequest = ApplicationRequest;

ApplicationRequest.prototype.notificationsCount = function () {
    return this.notifications.length;
};

ApplicationRequest.prototype.addNotification = function (notification) {
    if( notification != null ){
        this.notifications.push(notification);
    }
};

ApplicationRequest.prototype.toHeaders = function () {
    var headers = new Headers();
    var header = new Header();
    headers.addHeaders(this.application.toHeaders());
    headers.addHeader(header.stringValue(HeaderEnum.notificationsCount,this.notificationsCount()));
    for( var i in this.notifications ){
        headers.addHeader(header.blank());
        headers.addHeaders(this.notifications[i].toHeaders());
    }
    return headers;
};

ApplicationRequest.prototype.toRequest = function () {
    var req = new Request();
    req.type = this.type;
    req.headers.addHeaders(this.toHeaders());
    // crypto?
    return req;
};

/*----------------------------
    Notification object/class
*/
function Notification () {
    this.name = 'Node.js';
    this.displayName = this.name;
    this.enabled = true;
    this.icon = null;
}
exports.Notification = Notification;

Notification.prototype.toHeaders = function () {
    var headers = new Headers();
    var header = new Header();
    headers.addHeader(header.stringValue(HeaderEnum.notificationName,this.name));
    headers.addHeader(header.stringValue(HeaderEnum.notificationDisplayName,this.displayName));
    headers.addHeader(header.boolValue(HeaderEnum.notificationEnabled,this.enabled));
    headers.addHeader(header.resourceValue(HeaderEnum.notificationIcon,this.icon));
    return headers;
};

Notification.prototype.toRequest = function (){
    var req = new NotificationRequest();
    req.name = this.name;
    req.title = this.displayName;
    req.icon = this.icon;
    return req;
};

/*----------------------------
    NotificationRequest object/class
*/
var NotificationRequestCount = 0;
function NotificationRequest () {
    this.number = NotificationRequestCount++;
    // required, pragmatic
    this.type = RequestTypeEnum.NOTIFY;
    this.applicationName = null;
    this.name = 'Node.js';
    // not all required, variously non-pragmatic
    this.id = null;
    this.title = '';
    this.text = '';
    this.sticky = false; // bool
    this.priority = 0; // ranged -2 <=> 2
    this.icon = null;
    this.callbackContext = ''; // mutually exclusive of Target
    this.callbackContextType = ''; // Required with Context
    this.callbackTarget = ''; // mutually exclusive of Context
}
exports.NotificationRequest = NotificationRequest;

NotificationRequest.prototype.setPriority = function (priority) {
    if( priority >= -2 && priority <= 2){
        this.priority = priority;
    }
    return this.priority;
};

NotificationRequest.prototype.toHeaders = function () {
    var headers = new Headers();
    var header = new Header();
    headers.addHeader(header.stringValue(HeaderEnum.applicationName,this.applicationName));
    headers.addHeader(header.stringValue(HeaderEnum.notificationName,this.name));
    if( this.id != null ) headers.addHeader(header.stringValue(HeaderEnum.notificationId,this.id));
    headers.addHeader(header.stringValue(HeaderEnum.notificationTitle,this.title));
    if( this.text != null ) headers.addHeader(header.stringValue(HeaderEnum.notificationText,this.text));
    headers.addHeader(header.boolValue(HeaderEnum.notificationSticky,this.sticky));
    headers.addHeader(header.stringValue(HeaderEnum.notificationPriority,this.priority));
    if( this.icon != null ) headers.addHeader(header.resourceValue(HeaderEnum.notificationIcon,this.icon));
    if( this.callbackContext.length > 0 && this.callbackContextType.length > 0 ){
        headers.addHeader(header.stringValue(HeaderEnum.notificationCallbackContext,this.callbackContext));
        headers.addHeader(header.stringValue(HeaderEnum.notificationCallbackContextType,this.callbackContextType));
    }
    if( this.callbackTarget.length > 0 && this.callbackContext.length == 0 ){
        headers.addHeader(header.stringValue(HeaderEnum.notificationCallbackTarget,this.callbackTarget));
    }
    return headers;
};

NotificationRequest.prototype.toRequest = function () {
    var req = new Request();
    req.type = this.type;
    req.headers.addHeaders(this.toHeaders());
    // crypto?
    return req;
};

/*--------------------------
    Request object/class
    implements the ncessary translation to the string passed via sockets
*/
function Request () {
    this.type = RequestTypeEnum.UNKNOWN;
    this.headers = new Headers(); // headers
    this.crypto = null; // not implemented
}
exports.Request = Request;

Request.prototype.mimeString = function () {
    var buffer = new String;
    // replace NONE with the value of the crypto type.
    buffer = buffer.concat(Protocol.name,'/',Protocol.version,' ',this.type,' ','NONE',EndLine);
    // go through headers, section by section and type by type.
    var headerBuffer = new String;
    // headers
    for( h in this.headers.headers ){
        if( !this.headers.headers[h].isBlank ){
            headerBuffer = headerBuffer.concat(this.headers.headers[h].name,': ',this.headers.headers[h].value,EndLine);
        }else{
            headerBuffer = headerBuffer.concat(EndLine);
        }
    }
    // customHeaders
    for( h in this.headers.customHeaders ){
        if( !this.headers.customHeaders[h].isBlank ){
            headerBuffer = headerBuffer.concat(this.headers.customHeaders[h].name,': ',this.headers.customHeaders[h].value,EndLine);
        } // Blank not allowed in custom headers
    }
    // resourceHeaders - will generate sections
    for( h in this.headers.pointerHeaders ){
        // resource headers not supported yet.
    }
    // dataHeaders - will generate sections
    for( h in this.headers.headers ){
        // data headers not supported yet
    }
    // some magic will be done here when encryption is used.
    buffer = buffer.concat(headerBuffer);
    
    buffer = buffer.concat(EndLine,EndLine);
    return buffer;
};

/*--------------------------
    Client object/class
*/
var net = require('net');
function Client () {
    this.host = '127.0.0.1';
    this.port = 23053;
    this.password = '';
    this.debug = false;
}
exports.Client = Client;

Client.prototype.sendMessage = function (request,reponseCallback){
    var response;
    var sock = net.createConnection(this.port,this.host);
    sock.on('connect',function () {
        console.log('Request:\n'+request.mimeString());
        sock.end(request.mimeString());
    });
    sock.on('data',function (data){ 
        console.log('Response:\n'+data.toString('utf8')); 
    });
    sock.on('error',function (exception) { 
        console.log("error:"+exception); 
    });
    sock.on('close',function (had_error) { 
        console.log('socket closed.')
    });
    sock.on('timeout',function () { 
        console.log('timeout'); 
        sock.end(); 
    });
    
};
