/*
    A GNTP implementation for Node.js
*/

var events = require('events');
var net = require('net');
var crypt = require('crypto');
var fs = require('fs');
// Protocol
var Protocol = Object.freeze({ name : "GNTP", version : "1.0"});
exports.Protocol = Protocol;
var EndLine = "\r\n";
exports.EndLine = EndLine;

// Message types, includes both request and response
var MessageTypeEnum = Object.freeze({ UNKNOWN : "UNKNOWN", REGISTER : "REGISTER", NOTIFY : "NOTIFY", SUBSCRIBE : "SUBSCRIBE", POLL : "POLL", OK : "-OK", CALLBACK : "-CALLBACK", ERROR : "-ERROR" });
exports.MessageTypeEnum = MessageTypeEnum;

/*-------------------------------
    Hash - support
    sourced: view-source:http://rick.measham.id.au/javascript/hash.htm
    Copyright Rick Measham, 2006. All rights reserved.
    This library is free software; you can redistribute it and/or modify it under the GPL or under the same terms as Perl at your discresion.
*/
function Hash(){
    for( var i=0; i < arguments.length; i++ )
        for( var n in arguments[i] )
            if( arguments[i].hasOwnProperty(n) )
                this[n] = arguments[i][n];
}

// Hash.version = 1.00;    // Original version
// Hash.version = 1.01;    // Added ability to initialize in the constructor
// Hash.version = 1.02;    // Fixed document bug that showed a non-working example (thanks mareks)
//Hash.version = 1.03;    // Removed returning this from the constructor (thanks em-dash)
Hash.version = 1.04;    // Missed some 'var' declarations (thanks Twey)

Hash.prototype = {};

Hash.prototype.keys = function(){
    var rv = [];
    for( var n in this )
        if( this.hasOwnProperty(n) )
            rv.push(n);
    return rv;
};

Hash.prototype.length = function(){
    return this.keys().length();
};

Hash.prototype.values = function(){
    var rv = [];
    for( var n in this )
        if( this.hasOwnProperty(n) )
            rv.push(this[n]);
    return rv;
};

Hash.prototype.slice = function(){
    var rv = [];
    for( var i = 0; i < arguments.length; i++ )
        rv.push(( this.hasOwnProperty( arguments[i] ) ) ? this[arguments[i]] : undefined );
    return rv;
};

Hash.prototype.concat = function(){
    for( var i = 0; i < arguments.length; i++ )
        for( var n in arguments[i] )
            if( arguments[i].hasOwnProperty(n) )
                this[n] = arguments[i][n];
    return this;
};
/* --- END Hash -- */

/*-------------------------------
    Header object/class
    Implementation of all the valid headers for the GNTP protocol
    as of 1.0
*/
var HeaderEnum = Object.freeze({
   applicationIcon : 'Application-Icon',
   applicationName : 'Application-Name',
   trueValue : 'True',
   falseValue : 'False',
   customHeaderPrefix : 'X-',
   dataHeaderPrefix : 'Data-',
   errorCode : 'Error-Code',
   errorDescription : 'Error-Description',
   growlResourcePointerPrefix : 'x-growl-resource://',
   notificationCallbackContext : 'Notification-Callback-Context',
   notificationCallbackContextType : 'Notification-Callback-Context-Type',
   notificationCallbackResult : 'Notification-Callback-Result',
   notificationCallbackTarget : 'Notification-Callback-Target',
   notificationCoalescingId : 'Notification-Coalescing-ID',
   notificationDisplayName : 'Notification-Display-Name',
   notificationEnabled : 'Notification-Enabled',
   notificationIcon : 'Notification-Icon',
   notificationId : 'Notification-Id',
   notificationName : 'Notification-Name',
   notificationPriority : 'Notification-Priority',
   notificationSticky : 'Notification-Sticky',
   notificationText : 'Notification-Text',
   notificationTitle : 'Notification-Title',
   notificationsCount : 'Notifications-Count',
   originMachineName : 'Origin-Machine-Name',
   originPlatformName : 'Origin-Platform-Version',
   originPlatformVersion : 'Origin-Platform-Name',
   originSoftwareName : 'Origin-Software-Name',
   originSoftwareVersion : 'Origin-Software-Version',
   recieved : 'Recieved',
   resourceIdentifier : 'Identifier',
   resourceLength : 'Length',
   responseAction : 'Response-Action',
   subscriberId : 'Subscriber-ID',
   subscriberName : 'Subscriber-Name',
   subscriberPort : 'Subscriber-Port',
   subscriberTtl : 'Subscriber-TTL'
});
exports.HeaderEnum = HeaderEnum;

var HeaderBlankCount=0;

function Header(name,value,data){
    this.name = null; //string
    this.value = null; // string
    this.growlResource = null; // string - con
    this.growlResourcePointerID = null; // string
    
    this.isBlank = false; // bool
    this.isCustom = false; // bool
    this.isData = false; // bool
    this.isGrowlResourcePointer = false; // bool
    this.isResourceIdentifier = false; // bool
    this.isValid = false; // bool
    this.resourceData = undefined; // will be a Buffer object
    
    this.init(name,value,data);
}
exports.Header = Header;

Header.prototype.init = function (name,value,data) {
    this.name = name;
    this.value = value;
    this.resourceData = data;
    this.isValid = true;
    
    this.isBlank = ((name === null || name === undefined) && (value === null || value === undefined));
    if( !this.isBlank ){
        if( value !== null || value !== undefined ){ 
            if( value.toString().indexOf(HeaderEnum.growlResourcePointerPrefix) === 0) this.isGrowlResourcePointer = true;
            if( typeof value === 'bool') this.value = (value?HeaderEnum.trueValue:HeaderEnum.falseValue);
        }
        if( ( value !== null || value !== undefined ) && name === HeaderEnum.resourceIdentifier ) this.isResourceIdentifier = true;
        if( ( value !== null || value !== undefined ) && name.indexOf(HeaderEnum.customHeaderPrefix) === 0 ) this.isCustomHeader = true;
        if( ( value !== null || value !== undefined ) && name.indexOf(HeaderEnum.dataHeaderPrefix) === 0 ) this.isDataHeader = true;
    }else{
        this.name = "blank-header-" + HeaderBlankCount;
        HeaderBlankCount++;
    }
};


/*-------------------------------------
    Headers object/class
    Headers is an order collection of Header objects.
    This handles controlling the output in the correct order
    so that the user of the objects doesn't have to.
*/
function Headers() {
    // collections
    this.headers = [];
    this.customHeaders = [];
    this.dataHeaders = [];
    this.pointerHeaders = [];
    // this will be used for by name, only for checking existance.
    this.allHeaders = new Hash();
}
exports.Headers = Headers;

Headers.prototype.addHeader = function (header) {
    if( header !== null ){
        if( header.isValid === true){
            var ht = 0;
            if( header.isResourceIdentifier ){
                this.pointerHeaders.push(header);
                ht = 3;
            /*
            }else if( header.isCustom ){
                this.customHeaders.push(header);
                ht = 2;
            }else if( header.isData ){
                this.dataHeaders.push(header);
                ht = 1;
            */
            }else{
                this.headers.push(header);
            }
            this.allHeaders[header.name] = ht;
        }
    }
};

Headers.prototype.addHeaders = function (headers) {
    var i;
    for( i in headers.headers ) this.addHeader(headers.headers[i]);
    for( i in headers.customHeaders ) this.addHeader(headers.customHeaders[i]);
    for( i in headers.dataHeaders ) this.addHeader(headers.dataHeaders[i]);
    for( i in headers.pointerHeaders ) this.addHeader(headers.pointerHeaders[i]);
};

Headers.prototype.getHeader = function (name) {
    var head = new Header(null,null);
    var ht = this.allHeaders[name];
    if( ht !== null ){
        var hl;
        switch( ht ){
            case 0:
                hl = this.headers;
                break;
            case 1:
                hl = this.customHeaders;
                break;
            case 2:
                hl = this.dataHeaders;
                break;
            case 3:
                hl = this.pointerHeaders;
                break;
        }
        if( typeof hl ==='object'){
            for( var i=0; i<hl.length; i++){
                if( hl[i].name == name ){
                    head = hl[i];
                    break;
                }
            }
        }
    }
    return head;
};

/*------------------------------
    Application object/class
    Describes and application in the form of
*/
function Application (name) {
    this.name = name || 'node-gntp'; // String
    this.icon = null; // Resource or string
    
}
exports.Application = Application;

Application.prototype.toHeaders = function () {
    var headers = new Headers();
    var header = new Header();
    headers.addHeader(new Header(HeaderEnum.applicationName,this.name));
    if( this.icon !== null ){
        if( this.icon instanceof Buffer ) {
            // make MD5 unique to data...
            var uid = crypt.createHash('md5').update(this.icon).digest('hex');
            headers.addHeader(new Header(HeaderEnum.applicationIcon,HeaderEnum.growlResourcePointerPrefix + uid));
            headers.addHeader(new Header(HeaderEnum.resourceIdentifier,uid,this.icon));
        }
        if( this.icon instanceof String ) headers.addHeader(new Header(HeaderEnum.applicationIcon,this.icon));
        // this is where we would associate binary data ... if we supported it
    }
    return headers;
};
// why is $this empty in this function!!
Application.prototype.toRequest = function () {
    var req = new ApplicationRequest(this);
    return req;
};


/*------------------------------
    ApplicationRequest object/class
    Defines the content of REGISTER message
*/
function ApplicationRequest (application) {
    this.type = MessageTypeEnum.REGISTER; // RequestType
    this.application = null; // Application
    this.notifications = [];
    
    if( application !== null ){
        this.application = application;
    }
}
exports.ApplicationRequest = ApplicationRequest;

ApplicationRequest.prototype.notificationsCount = function () {
    return this.notifications.length;
};

ApplicationRequest.prototype.addNotification = function (notification) {
    if( notification !== null ){
        this.notifications.push(notification);
    }
};

ApplicationRequest.prototype.toHeaders = function () {
    var headers = new Headers();
    var header = new Header();
    headers.addHeaders(this.application.toHeaders());
    headers.addHeader(new Header(HeaderEnum.notificationsCount,this.notificationsCount()));
    for( var i in this.notifications ){
        headers.addHeader(new Header());
        headers.addHeaders(this.notifications[i].toHeaders());
    }
    return headers;
};

ApplicationRequest.prototype.toRequest = function () {
    var req = new Message();
    req.type = this.type;
    req.headers.addHeaders(this.toHeaders());
    return req;
};

/*----------------------------
    Notification object/class
*/
function Notification () {
    this.name = 'Node.js';
    this.displayName = this.name;
    this.enabled = true;
    this.icon = null;
}
exports.Notification = Notification;

Notification.prototype.toHeaders = function () {
    var headers = new Headers();
    var header = new Header();
    headers.addHeader(new Header(HeaderEnum.notificationName,this.name));
    headers.addHeader(new Header(HeaderEnum.notificationDisplayName,this.displayName));
    headers.addHeader(new Header(HeaderEnum.notificationEnabled,this.enabled));
    if( this.icon !== null ){
        if( this.icon instanceof Buffer ) {
            // make MD5 unique to data...
            var uid = crypt.createHash('md5').update(this.icon).digest('hex');
            headers.addHeader(new Header(HeaderEnum.notificationIcon,HeaderEnum.growlResourcePointerPrefix + uid));
            headers.addHeader(new Header(HeaderEnum.resourceIdentifier,uid,this.icon));
        }
        if( this.icon instanceof String ) headers.addHeader(new Header(HeaderEnum.applicationIcon,this.icon));
    }
    return headers;
};

Notification.prototype.toRequest = function (){
    var req = new NotificationRequest();
    req.name = this.name;
    req.title = this.displayName;
    req.icon = this.icon;
    return req;
};

/*----------------------------
    NotificationRequest object/class
*/
var NotificationRequestCount = 0;
function NotificationRequest () {
    this.number = NotificationRequestCount++;
    // required, pragmatic
    this.type = MessageTypeEnum.NOTIFY;
    this.applicationName = null;
    this.name = 'Node.js';
    // not all required, variously non-pragmatic
    this.id = null;
    this.title = '';
    this.text = '';
    this.sticky = false; // bool
    this.priority = 0; // ranged -2 <=> 2
    this.icon = null;
    this.callbackContext = ''; // mutually exclusive of Target
    this.callbackContextType = ''; // Required with Context
    this.callbackTarget = ''; // mutually exclusive of Context
}
exports.NotificationRequest = NotificationRequest;

NotificationRequest.prototype.setPriority = function (priority) {
    if( priority >= -2 && priority <= 2){
        this.priority = priority;
    }
    return this.priority;
};

NotificationRequest.prototype.toHeaders = function () {
    var headers = new Headers();
    var header = new Header();
    headers.addHeader(new Header(HeaderEnum.applicationName,this.applicationName));
    headers.addHeader(new Header(HeaderEnum.notificationName,this.name));
    if( this.id !== null ) headers.addHeader(new Header(HeaderEnum.notificationId,this.id));
    headers.addHeader(new Header(HeaderEnum.notificationTitle,this.title));
    if( this.text !== null ) headers.addHeader(new Header(HeaderEnum.notificationText,this.text));
    headers.addHeader(new Header(HeaderEnum.notificationSticky,this.sticky));
    headers.addHeader(new Header(HeaderEnum.notificationPriority,this.priority));
    if( this.icon !== null ){
        if( this.icon instanceof Buffer ) {
            // make MD5 unique to data...
            var uid = crypt.createHash('md5').update(this.icon).digest('hex');
            headers.addHeader(new Header(HeaderEnum.notificationIcon,HeaderEnum.growlResourcePointerPrefix + uid));
            headers.addHeader(new Header(HeaderEnum.resourceIdentifier,uid,this.icon));
        }
        if( this.icon instanceof String ) headers.addHeader(new Header(HeaderEnum.applicationIcon,this.icon));
        // this is where we would associate binary data ... if we supported it
    }
    if( this.callbackContext.length > 0 && this.callbackContextType.length > 0 ){
        headers.addHeader(new Header(HeaderEnum.notificationCallbackContext,this.callbackContext));
        headers.addHeader(new Header(HeaderEnum.notificationCallbackContextType,this.callbackContextType));
    }
    if( this.callbackTarget.length > 0 && this.callbackContext.length === 0 ){
        headers.addHeader(new Header(HeaderEnum.notificationCallbackTarget,this.callbackTarget));
    }
    return headers;
};

NotificationRequest.prototype.toRequest = function () {
    var req = new Message();
    req.type = this.type;
    req.headers.addHeaders(this.toHeaders());
    // crypto?
    return req;
};

/*-------------------------
    Message object
*/
function Message (mimeString) {
    this.type = MessageTypeEnum.UNKNOWN;
    this.sections = [];
    this.headers = new Headers();
    this.crypto = null;
    
    this.chunkSize = 1024;
    this.raw = new Buffer(this.chunkSize);
    this.parseInfo = {
        lastPosition : 0,
        sections : { current : 0, expected : 1},
        resource : { current : 0, length : 0},
        received : 0
    };
    if( typeof mimeString === 'string' ){
        this.parse(mimeString);
    }
}
exports.Message = Message;

Message.prototype.parse = function (mime){
    if ( !(mime instanceof Buffer) ){
        return undefined;
    }
    if( mime.length + this.parseInfo.received > this.raw.length ){
        var upSize = mime.length+this.parseInfo.received;
        var tmp = new Buffer(upSize);
        this.raw.copy(tmp);
        this.raw = tmp;
    }
    mime.copy(this.raw,this.parseInfo.received);
    this.parseInfo.received += mime.length;
    
    var self = this,
        len = this.parseInfo.received,
        hdr,
        resourceLength = 0,
        prev = this.parseInfo.lastPosition, 
        curr = 0, 
        lines = [], 
        work,
        line,
        lineEnd,
        gap,
        protocol,
        security,
        resource = false,
        parts,
        block,
        //expectedSections = this.parseInfo.sections.expected,
        header =  new Header(); // i need to fix this object...
        
    var findEndSection = function (buff,start){
        if( buff instanceof Buffer){
            if( buff.length >= 4 &&
                start < buff.length){
                for( var i=start; i < buff.length -3; i++ ){
                    if( buff[i+0] == 13 && buff[i+1] == 10 &&
                        buff[i+2] == 13 && buff[i+3] == 10 ){
                        //End!
                        return i;
                    }
                }
            }
        }
        return -1;
    };
    
    var findEndLine = function (buff){
        if( ( buff instanceof Buffer ) && buff.length >= 2){
            for( var i=0; i < buff.length -1; i++ ){
                if( buff[i+0] == 13 && buff[i+1] == 10 ){
                    //End!
                    return i;
                }
            }
        }
        return -1;
    };
    
    var processBlock = function(block){
        var lines = block.toString('utf8').split('\r\n');
        for( var i=0; i < lines.length; i++){
            line = lines[i];
            parts = [ line.substring(0,line.indexOf(':')), line.substring(line.indexOf(':')+2)];
            hdr = new Header(parts[0],parts[1]);
            // NotificationsCount will increase expected sections by x.
            if( hdr.name === HeaderEnum.notificationsCount ) {
                self.parseInfo.sections.expected += Number(hdr.value);
                //console.log('notificationsCount: '+ hdr.value);
            }
            // Resource Pointers will increase expected sections by 2
            if( hdr.isGrowlResourcePointer ) {
                //console.log('resourceIdentifier found:'+hdr.value);
                self.parseInfo.sections.expected += 2;
            }
            
            // add it to the message headers.
            self.headers.addHeader(hdr);
        }
        //console.log('sections (have/expecting): '+self.parseInfo.sections.current +'/'+self.parseInfo.sections.expected);
        
    };
    
    while(curr < len && curr > -1){
        curr = findEndSection(this.raw,prev);
        if( curr > -1 ){
            this.parseInfo.sections.current++;
            work = this.raw.slice(prev,curr);
            
            if( this.parseInfo.sections.current == 1 ){
                // always in section 1:
                // GNTP protocol header
                // & headers (which may be an encrypted block)
                
                // parse protocol string, and setup crypto as required.
                lineEnd = findEndLine(work,0);
                if( lineEnd === -1 ){
                    console.log('EOL failure: '+work.length);
                    return undefined;
                }
                line = work.slice(0,lineEnd).toString('utf8');
                gap = line.indexOf(' ');
                protocol = line.substring(0,gap).split('/');
                if( protocol[0] != Protocol.name || protocol[1] != Protocol.version ){
                    console.log('bad protocol/version');
                    throw 'GNTP protocol mismatch';
                }
                
                this.type = line.substring(gap+1,line.indexOf(' ',gap+1));
                //console.log('message type: ' + this.type + ' => ' + (this.type.substr(0,1) === '-'?'response':'request'));
                
                // check for the password & encryption
                gap = line.indexOf(' ',gap+1);
                //console.log('pwd & sec: '+gap);
                security = line.substring(line.indexOf(' ',gap)+1);
                //console.log('sec string: "'+security+'"');
                gap = security.indexOf(' ');
                //console.log('sec str gap:'+gap);
                //TODO: dont hardset the password..
                this.crypto = new Crypto('nodejs','sha1');
                if( gap > -1 ){
                    security = security.split(' ');
                    if( security[0] !== 'NONE' ){
                        security[0] = security[0].split(':');
                        this.crypto.useEncryption = true;
                        this.crypto.encryptAlg = security[0][0].toLowerCase();
                        this.crypto.iv = new Buffer(security[0][1].length/2);
                        this.crypto.iv.write(security[0][1],'hex');
                    }
                    security[1] = security[1].split(':');
                    this.crypto.hashAlg = security[1][0].toLowerCase();
                    security[1][1] = security[1][1].split('.');
                    if( !this.crypto.setKeyString(security[1][1][0],security[1][1][1]) ){
                        throw 'bad authentication';
                    }
                }else{
                    this.crypto.password = '';
                }
                block = new Buffer(work.slice(lineEnd+2).length);
                work.slice(lineEnd+2).copy(block,0,0);
                
                if( this.crypto.useEncryption ){
                    // decrypt the block first.
                    block = this.crypto.decryptBuffer(block);
                }
                
                // process the headers
                processBlock(block);
                
            }else{
                // is this is the data part of a resource, handle accordingly.
                if( this.parseInfo.resource.length > 0){
                    //console.log('reading RP: rl['+ this.parseInfo.resource.length + '] wl['+ work.length + ']');
                    if( this.parseInfo.resource.length === work.length ){
                        // find the associated header
                        for( var h=0; h<this.headers.pointerHeaders.length; h++){
                            if( this.headers.pointerHeaders[h].value === this.parseInfo.resource.identifier ){
                                hdr = this.headers.pointerHeaders[h]
                            }
                        }
                        // this goes directly to a buffer
                        if( this.crypto.useEncryption ){
                            hdr.resourceData = this.crypto.decryptBuffer(work);
                        }else{
                            hdr.resourceData = new Buffer(work.length);
                            work.copy(hdr.resourceData,0,0);
                        }
                        // add it to the messages
                        //this.headers.addHeader(hdr);
                        // reset resource information.
                        this.parseInfo.resource.length = 0;
                        this.parseInfo.resource.current = 0;
                        this.parseInfo.resource.identifier = undefined;
                    }else{
                        // we're in the middle of a resource, but haven't received it all.
                        console.log('partial resource');
                        // don't count it complete yet (decrement sections)
                        this.parseInfo.sections.current--;
                        // we should do something to bypass this break, but record it so we include it.
                        this.parseInfo.resource.current = curr+4;
                    }
                }else{
                    // check encryption, and remember that Identifier headers are NOT encryped.
					if( work.length >= HeaderEnum.resourceIdentifier.length ){
						line = work.slice(0,HeaderEnum.resourceIdentifier.length).toString('utf8');
					}else{
						line = '';
					}
                    //console.log('line: ['+line+'] header:'+HeaderEnum.resourceIdentifier);
                    // check if it is a identifier 
                    if( line.substr(0,HeaderEnum.resourceIdentifier.length) === HeaderEnum.resourceIdentifier){
                        //console.log(':: RESOURCE IDENTIFIER');
                        // Get ID
                        lineEnd = findEndLine(work,0);
                        line = work.toString('utf8').split(EndLine);
                        //console.log(parts);
                        //console.log('I:'+line[0]);
                        parts = [ line[0].substring(0,line[0].indexOf(':')), line[0].substring(line[0].indexOf(':')+2)];
                        //console.log(parts);
                        hdr = new Header(parts[0],parts[1]);
                        this.headers.addHeader(hdr);
                        this.parseInfo.resource.identifier = parts[1];
                        // Get length
                        //console.log('L:'+line[1]);
                        parts = [ line[1].substring(0,line[1].indexOf(':')), line[1].substring(line[1].indexOf(':')+2)];
                        //console.log(parts);
                        this.parseInfo.resource.length = Number(parts[1]);
                        this.parseInfo.resource.current = 0;
                        //console.log(this.parseInfo.resource);
                    }else{
                        // Not an identifier, or identifier data
                        //console.log(':: NOT resource');
                        block = new Buffer(work.length);
                        work.copy(block,0,0);
                        
                        if( this.crypto.useEncryption ){
                            // decrypt the block first.
                            block = this.crypto.decryptBuffer(block);
                        }
                        
                        processBlock(block);
                    }
                }
            }
            // skip past the section end marker.
            prev = curr+4;
        }else{
            this.parseInfo.lastPosition = prev;
            // No section end found.. is this the end of the message?
            // If it is not, throw the rest of the message.
            // What if we still expected more?
            if( this.parseInfo.sections.current < this.parseInfo.sections.expected ){
                // wth, why are there spares?
                //console.log('EOP:false');
                //console.log(this.parseInfo);
                return false;
            }else{
                // we seem to be done...
                //console.log('EOP:true');
                return true;
            }
        }
    }
    // WTF making it here... This function should never reach this line.
    //console.log('EOP:end!');
    //console.log(this.parseInfo);
    return undefined;
};

Message.prototype.protocolString = function (){
    var buffer = '';
    // replace NONE with the value of the crypto type.
    var securityString = 'NONE';
    if( this.crypto instanceof Crypto){
        securityString = this.crypto.getSecurityString();
    }
    buffer = buffer.concat(Protocol.name,'/',Protocol.version,' ',this.type,' ',securityString,EndLine);
    return buffer;
};

Message.prototype.mime = function () {
    /*
        Some notes on headers:
        First is all the actual text headers, then any identifiers & their data.
        There is one exception here, and that is in the Register message
        wherein there are the Application headers, then the Notifictions headers
        for setting Notifications up, and *then* there are the identifiers.
        Identifiers are formatted as such to create 2 sections per identifier:
        --
        Identifier: xxxxx\r\n
        Length: \r\n
        \r\n
        data\r\n
        \r\n
        --
        This library handles things in the register method by allowing you to 
        create 'blank' headers, that are strictly used by the Register method.
        This needs refactored to say the least.
    */
    // go through headers, section by section and type by type.
    var headerBuffer = '', resourceBuffer='';
    var h;
    var hBuff = '', rBuff = '', bBuff = '', tBuff = '';
    // headers
    for( h in this.headers.headers ){
        if( !this.headers.headers[h].isBlank ){
            headerBuffer = headerBuffer.concat(this.headers.headers[h].name,': ',this.headers.headers[h].value,EndLine);
        }else{
            headerBuffer = headerBuffer.concat(EndLine);
        }
    }
    // customHeaders - for passing one-way information to some custom display, etc
    for( h in this.headers.customHeaders ){
        if( !this.headers.customHeaders[h].isBlank ){
            headerBuffer = headerBuffer.concat(this.headers.customHeaders[h].name,': ',this.headers.customHeaders[h].value,EndLine);
        } // Blank not allowed in custom headers
    }
    
    // dataHeaders - for passing data that WILL be returned in the response
    for( h in this.headers.dataHeaders ){
        // erm.. yes. they just show up in the normals?
    }
    // this line breaks resources?
    //headerBuffer = headerBuffer.concat(EndLine);
    
    // convert the utf8 text into a Buffer
    hBuff = new Buffer(headerBuffer);
    
    //  If this message is supposed to be encrypted, encrypt the buffer
    //  - the response is a buffer object of the appropriate size, a replacement
    if( this.crypto instanceof Crypto && this.crypto.useEncryption){
        hBuff = this.crypto.encryptBuffer(hBuff);
        bBuff = new Buffer(hBuff.length+EndLine.length);
        hBuff.copy(bBuff,0,0);
        bBuff.write(EndLine,bBuff.length-2,0);
        hBuff = bBuff; 
    }
    
    bBuff = new Buffer(hBuff.length+EndLine.length);
    hBuff.copy(bBuff,0,0);
    bBuff.write(EndLine,bBuff.length-2,0);
    hBuff = bBuff; 
    
    // generates a section
    // resourceHeaders - will generate sections
    for( h in this.headers.pointerHeaders ){
        if( this.headers.pointerHeaders[h].resourceData instanceof Buffer){
            resourceBuffer = '';
            resourceBuffer += HeaderEnum.resourceIdentifier + ': ' + this.headers.pointerHeaders[h].value + EndLine;
            
            bBuff = this.headers.pointerHeaders[h].resourceData;
            //  If this message is supposed to be encrypted, encrypt the buffer
            //  - the response is a buffer object of the appropriate size, a replacement
            if( this.crypto instanceof Crypto && this.crypto.useEncryption){
                bBuff = this.crypto.encryptBuffer(bBuff);
                //console.log('rData-enc: '+bBuff.length);
            }
            
            resourceBuffer += 'Length: ' + bBuff.length + EndLine + EndLine;
            
            tBuff = new Buffer(bBuff.length+resourceBuffer.length+(EndLine.length*2));
            tBuff.write(resourceBuffer,0,'utf8');
            bBuff.copy(tBuff,resourceBuffer.length,0,bBuff.length);
            tBuff.write(EndLine+EndLine,resourceBuffer.length+bBuff.length,'utf8');
            // we've copied out to tBuff, so bBuff can be resused
            if( rBuff instanceof Buffer ) {
                bBuff = rBuff;
            }else{
                bBuff = '';
            }
            
            rBuff = new Buffer(rBuff.length+tBuff.length);
            if( bBuff instanceof Buffer) bBuff.copy(rBuff,0,0);
            tBuff.copy(rBuff,bBuff.length,0);
        }
    }
    
    // convert the utf8 text into a Buffer
    bBuff = new Buffer(hBuff.length+rBuff.length);
    hBuff.copy(bBuff,0,0);
    if( rBuff instanceof Buffer ){
        rBuff.copy(bBuff,hBuff.length,0);
    }
    
    return bBuff;
};

/*--------------------------
    Client object/class
*/
function Client () {
    this.host = '127.0.0.1';
    this.port = 23053;
    this.password = '';
    this.debug = false;
    
    events.EventEmitter.call(this);
}
Client.prototype = new events.EventEmitter();
exports.Client = Client;

Client.prototype.sendMessage = function (request){
    var response;
    var sock = net.createConnection(this.port,this.host);
    var self = this;
    var chunkSize = 1024;
    var eomLength = 6;
    var recvd = 0;
    var msgdata = new Buffer(chunkSize);
    var message = new Message();
    //sock.setTimeout(3000);
    sock.on('connect',function () {
        var protocol = request.protocolString();
        var mime = request.mime();
        var mBuff = new Buffer(protocol.length+mime.length+(EndLine.length));
        mBuff.write(protocol,0,'utf8');
        mime.copy(mBuff,protocol.length,0);
        mBuff.write(EndLine,protocol.length+mime.length,'utf8');
        
        sock.write(mBuff);
        
        
        self.emit('sent');
    });
    sock.on('data',function (data){
        
        var tmp, eom = false;
        //console.log('Recv:\r\n'+data.toString());
        
        eom = message.parse(data);
        if( eom === true ){
            //console.log('emitting response!');
            self.emit('response',message);
        }
    });
    sock.on('error',function (exception) { 
        console.log("socket error:"+exception); 
    });
	sock.on('end',function () {
		sock.destroy();
	});
    sock.on('close',function (had_error) { 
        //console.log('socket closed.'+(had_error?' with eror':''));
    });
    sock.on('timeout',function () { 
        console.log('socket timeout'); 
        sock.destroy(); 
    });
    
};

/*--------------------
    Crypto class/object
    provides password and encryption capabilities.
*/
function Crypto(password,hash,encrypt){
    this.password = password || '';
    this.hashAlg = hash || 'sha256';
    this.encryptAlg = encrypt || 'AES';
    
    this.salt = crypt.randomBytes(16);
    this.iv =  crypt.randomBytes(16);
    
    this.useEncryption = (encrypt?true:false);
}
exports.Crypto = Crypto;

Crypto.prototype.setKeyString = function (keyHash,saltHex){
    this.salt = new Buffer(saltHex.length/2);
    this.salt.write(saltHex,'hex');
    var key = this.getKeyString();
    return (key === keyHash);
};

Crypto.prototype.getKeyString = function (){
    // this will cause WHACKY behavior without a password set.
    var passwordBuffer = new Buffer(this.password);
    var keyBasis = new Buffer(passwordBuffer.length+this.salt.length);
    passwordBuffer.copy(keyBasis,0,0);
    this.salt.copy(keyBasis,passwordBuffer.length,0);
    var key = crypt.createHash(this.hashAlg).update(keyBasis).digest('hex');
    this.key = new Buffer(key.length/2);
    this.key.write(key,'hex');
    var keyHash = crypt.createHash(this.hashAlg).update(crypt.createHash(this.hashAlg).update(keyBasis).digest()).digest('hex').toUpperCase();
    return keyHash;
};

Crypto.prototype.getSecurityString = function (){
    var security = 'NONE';
    if( this.password !== ''){
        if( this.useEncryption ){
            var ivLen = 8;
            if( this.encryptAlg.toUpperCase() === 'AES') { alg = 'aes192'; ivLen = 16; }
            if( this.encryptAlg.toUpperCase() === 'DES') keyLen = 8;
            if( this.encryptAlg.toUpperCase() === '3DES') alg = 'des3';
            security = this.encryptAlg.toUpperCase()+':'+this.iv.toString('hex').toUpperCase().substr(0,ivLen*2);
        }
        security += ' '+this.hashAlg.toUpperCase()+':'+this.getKeyString()+'.'+this.salt.toString('hex').toUpperCase();
    }
    return security;
};

Crypto.prototype.encryptBuffer = function (mime) {
    this.getKeyString();
    var keyB = this.key;
    var alg = this.encryptAlg;
    var keyLen = 24;
    var ivLen = 8;
    if( this.encryptAlg.toUpperCase() === 'AES') { alg = 'aes192'; ivLen = 16; }
    if( this.encryptAlg.toUpperCase() === 'DES') { alg = 'des'; keyLen = 8; }
    if( this.encryptAlg.toUpperCase() === '3DES') { alg = 'des3'; }
    var crypto = new crypt.createCipheriv(alg,keyB.toString('binary').substr(0,keyLen),this.iv.toString('binary').substr(0,ivLen));
    
    var ret = crypto.update(mime,null,'hex');
    var fin = crypto.final('hex');
    ret+=fin;
    
    var retBuff= new Buffer(ret.length/2);
    retBuff.write(ret,'hex');
    
    return retBuff;
};

Crypto.prototype.decryptBuffer = function (mime) {
    this.getKeyString();
    var keyB = this.key;
    var alg = this.encryptAlg;
    var keyLen = 24;
    var ivLen = 8;
    if( this.encryptAlg.toUpperCase() === 'AES') { alg = 'aes192'; ivLen = 16; }
    if( this.encryptAlg.toUpperCase() === 'DES') { alg = 'des'; keyLen = 8; }
    if( this.encryptAlg.toUpperCase() === '3DES') { alg = 'des3'; }
    var crypto = new crypt.createDecipheriv(alg,keyB.toString('binary').substr(0,keyLen),this.iv.toString('binary').substr(0,ivLen));
    
    var ret = crypto.update(mime,null,'binary');
    var fin = crypto.final('binary');
    ret+=fin;
    
    var retBuff= new Buffer(ret,'binary');
    
    return retBuff;
};