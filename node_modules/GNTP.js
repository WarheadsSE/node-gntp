/*
    A GNTP implementation for Node.js
*/
// We'll be emitting some events..
var EventEmitter = require('events').EventEmiter;

// Protocol
var Protocol = Object.freeze({ name : "GNTP", version : "1.0"});
var EndLine = "\r\n";

// Message types, includes both request and response
var MessageTypeEnum = Object.freeze({ UNKNOWN : "UNKNOWN", REGISTER : "REGISTER", NOTIFY : "NOTIFY", SUBSCRIBE : "SUBSCRIBE", POLL : "POLL", OK : "-OK", CALLBACK : "-CALLBACK", ERROR : "-ERROR" });
exports.MessageTypeEnum = MessageTypeEnum;

/*-------------------------------
    Hash - support
    sourced: view-source:http://rick.measham.id.au/javascript/hash.htm
    Copyright Rick Measham, 2006. All rights reserved.
    This library is free software; you can redistribute it and/or modify it under the GPL or under the same terms as Perl at your discresion.
*/
function Hash(){
    for( var i=0; i < arguments.length; i++ )
        for( var n in arguments[i] )
            if( arguments[i].hasOwnProperty(n) )
                this[n] = arguments[i][n];
}

// Hash.version = 1.00;	// Original version
// Hash.version = 1.01;	// Added ability to initialize in the constructor
// Hash.version = 1.02;	// Fixed document bug that showed a non-working example (thanks mareks)
//Hash.version = 1.03;	// Removed returning this from the constructor (thanks em-dash)
Hash.version = 1.04;	// Missed some 'var' declarations (thanks Twey)

Hash.prototype = {};

Hash.prototype.keys = function(){
    var rv = [];
    for( var n in this )
        if( this.hasOwnProperty(n) )
            rv.push(n);
    return rv;
};

Hash.prototype.length = function(){
    return this.keys().length();
};

Hash.prototype.values = function(){
    var rv = [];
    for( var n in this )
        if( this.hasOwnProperty(n) )
            rv.push(this[n]);
    return rv;
};

Hash.prototype.slice = function(){
    var rv = [];
    for( var i = 0; i < arguments.length; i++ )
        rv.push(( this.hasOwnProperty( arguments[i] ) ) ? this[arguments[i]] : undefined );
    return rv;
};

Hash.prototype.concat = function(){
    for( var i = 0; i < arguments.length; i++ )
        for( var n in arguments[i] )
            if( arguments[i].hasOwnProperty(n) )
                this[n] = arguments[i][n];
    return this;
};
/* --- END Hash -- */

/*-------------------------------
    Header object/class
    Implementation of all the valid headers for the GNTP protocol
    as of 1.0
*/
var HeaderEnum = Object.freeze({
   applicationIcon : 'Application-Icon',
   applicationName : 'Application-Name',
   trueValue : 'True',
   falseValue : 'False',
   customHeaderPrefix : 'X-',
   dataHeaderPrefix : 'Data-',
   errorCode : 'Error-Code',
   errorDescription : 'Error-Description',
   growlResourcePointerPrefix : 'x-growl-resource://',
   notificationCallbackContext : 'Notification-Callback-Context',
   notificationCallbackContextType : 'Notification-Callback-Context-Type',
   notificationCallbackResult : 'Notification-Callback-Result',
   notificationCallbackTarget : 'Notification-Callback-Target',
   notificationCoalescingId : 'Notification-Coalescing-ID',
   notificationDisplayName : 'Notification-Display-Name',
   notificationEnabled : 'Notification-Enabled',
   notificationIcon : 'Notification-Icon',
   notificationId : 'Notification-Id',
   notificationName : 'Notification-Name',
   notificationPriority : 'Notification-Priority',
   notificationSticky : 'Notification-Sticky',
   notificationText : 'Notification-Text',
   notificationTitle : 'Notification-Title',
   notificationsCount : 'Notifications-Count',
   originMachineName : 'Origin-Machine-Name',
   originPlatformName : 'Origin-Platform-Version',
   originPlatformVersion : 'Origin-Platform-Name',
   originSoftwareName : 'Origin-Software-Name',
   originSoftwareVersion : 'Origin-Software-Version',
   recieved : 'Recieved',
   resourceIdentifier : 'Identifier',
   resourceLength : 'Length',
   responseAction : 'Response-Action',
   subscriberId : 'Subscriber-ID',
   subscriberName : 'Subscriber-Name',
   subscriberPort : 'Subscriber-Port',
   subscriberTtl : 'Subscriber-TTL'
});
exports.HeaderEnum = HeaderEnum;

var HeaderBlankCount=0;

function Header(name,value){
    this.name = null; //string
    this.value = null; // string
    this.growlResource = null; // string
    this.growlResourcePointerID = null; // string
    
    this.isBlank = false; // bool
    this.isCustom = false; // bool
    this.isData = false; // bool
    this.isGrowlResourcePointer = false; // bool
    this.isResourceIdentifier = false; // bool
    this.isValid = false; // bool
    this.init(name,value);
}
exports.Header = Header;

Header.prototype.init = function (name,value) {
    this.name = name;
    this.value = value;
    this.isValid = true;
    
    this.isBlank = ((name === null || name === undefined) && (value === null || value === undefined));
    if( !this.isBlank ){
        if( value !== null ){ 
            if( value.toString().indexOf(HeaderEnum.growlResourcePointerPrefix) === 0) this.isGrowlResourcePointer = true;
            if( typeof value === 'bool') this.value = (value?HeaderEnum.trueValue:HeaderEnum.falseValue);
        }
        if( name !== null && name == HeaderEnum.resourceIdentifier ) this.isResourceIdentifier = true;
        if( name !== null && name.indexOf(HeaderEnum.customHeaderPrefix) === 0 ) this.isCustomHeader = true;
		if( name !== null && name.indexOf(HeaderEnum.dataHeaderPrefix) === 0 ) this.isDataHeader = true;
    }else{
        this.name = "blank-header-" + HeaderBlankCount;
        HeaderBlankCount++;
    }
};


/*-------------------------------------
    Headers object/class
    Headers is an order collection of Header objects.
    This handles controlling the output in the correct order
    so that the user of the objects doesn't have to.
*/
function Headers() {
    // collections
    this.headers = [];
    this.customHeaders = [];
    this.dataHeaders = [];
    this.pointerHeaders = [];
    // this will be used for by name, only for checking existance.
    this.allHeaders = new Hash();
}
exports.Headers = Headers;

Headers.prototype.addHeader = function (header) {
    if( header !== null ){
        if( header.isValid === true){
            var ht = 0;
            if( header.isGrowlResourcePointer ){
                this.pointerHeaders.push(header);
                ht = 3;
            }else if( header.isCustom ){
                this.customHeaders.push(header);
                ht = 2;
            }else if( header.isData ){
                this.dataHeaders.push(header);
                ht = 1;
            }else{
                this.headers.push(header);
            }
            this.allHeaders[header.name] = ht;
        }
    }
};

Headers.prototype.addHeaders = function (headers) {
    var i;
    for( i in headers.headers ) this.addHeader(headers.headers[i]);
    for( i in headers.customHeaders ) this.addHeader(headers.customHeaders[i]);
    for( i in headers.dataHeaders ) this.addHeader(headers.dataHeaders[i]);
    for( i in headers.pointerHeaders ) this.addHeader(headers.pointerHeaders[i]);
};

Headers.prototype.getHeader = function (name) {
    var head = new Header(null,null);
    var ht = this.allHeaders[name];
    if( ht !== null ){
        var hl;
        switch( ht ){
            case 0:
                hl = this.headers;
                break;
            case 1:
                hl = this.customHeaders;
                break;
            case 2:
                hl = this.dataHeaders;
                break;
            case 3:
                hl = this.pointerHeaders;
                break;
        }
        if( typeof hl ==='object'){
            for( var i=0; i<hl.length; i++){
                if( hl[i].name == name ){
                    head = hl[i];
                    break;
                }
            }
        }
    }
    return head;
};

/*------------------------------
    Application object/class
    Describes and application in the form of
*/
function Application (name) {
    this.name = name || 'node-gntp'; // String
    this.icon = null; // Resource
    
}
exports.Application = Application;

Application.prototype.toHeaders = function () {
    var headers = new Headers();
    var header = new Header();
    headers.addHeader(new Header(HeaderEnum.applicationName,this.name));
    if( this.icon !== null ){
        headers.addHeader(new Header(HeaderEnum.applicationIcon,this.icon));
        // this is where we would associate binary data ... if we supported it
    }
    return headers;
};
// why is $this empty in this function!!
Application.prototype.toRequest = function () {
    var req = new ApplicationRequest(this);
    return req;
};


/*------------------------------
    ApplicationRequest object/class
    Defines the content of REGISTER message
*/
function ApplicationRequest (application) {
    this.type = MessageTypeEnum.REGISTER; // RequestType
    this.application = null; // Application
    this.notifications = [];
    
    if( application !== null ){
        this.application = application;
    }
}
exports.ApplicationRequest = ApplicationRequest;

ApplicationRequest.prototype.notificationsCount = function () {
    return this.notifications.length;
};

ApplicationRequest.prototype.addNotification = function (notification) {
    if( notification !== null ){
        this.notifications.push(notification);
    }
};

ApplicationRequest.prototype.toHeaders = function () {
    var headers = new Headers();
    var header = new Header();
    headers.addHeaders(this.application.toHeaders());
    headers.addHeader(new Header(HeaderEnum.notificationsCount,this.notificationsCount()));
    for( var i in this.notifications ){
        headers.addHeader(new Header());
        headers.addHeaders(this.notifications[i].toHeaders());
    }
    return headers;
};

ApplicationRequest.prototype.toRequest = function () {
    var req = new Message();
    req.type = this.type;
    req.headers.addHeaders(this.toHeaders());
    // crypto?
    return req;
};

/*----------------------------
    Notification object/class
*/
function Notification () {
    this.name = 'Node.js';
    this.displayName = this.name;
    this.enabled = true;
    this.icon = null;
}
exports.Notification = Notification;

Notification.prototype.toHeaders = function () {
    var headers = new Headers();
    var header = new Header();
    headers.addHeader(new Header(HeaderEnum.notificationName,this.name));
    headers.addHeader(new Header(HeaderEnum.notificationDisplayName,this.displayName));
    headers.addHeader(new Header(HeaderEnum.notificationEnabled,this.enabled));
    if( this.icon !== null )headers.addHeader(new Header(HeaderEnum.notificationIcon,this.icon));
    return headers;
};

Notification.prototype.toRequest = function (){
    var req = new NotificationRequest();
    req.name = this.name;
    req.title = this.displayName;
    req.icon = this.icon;
    return req;
};

/*----------------------------
    NotificationRequest object/class
*/
var NotificationRequestCount = 0;
function NotificationRequest () {
    this.number = NotificationRequestCount++;
    // required, pragmatic
    this.type = MessageTypeEnum.NOTIFY;
    this.applicationName = null;
    this.name = 'Node.js';
    // not all required, variously non-pragmatic
    this.id = null;
    this.title = '';
    this.text = '';
    this.sticky = false; // bool
    this.priority = 0; // ranged -2 <=> 2
    this.icon = null;
    this.callbackContext = ''; // mutually exclusive of Target
    this.callbackContextType = ''; // Required with Context
    this.callbackTarget = ''; // mutually exclusive of Context
}
exports.NotificationRequest = NotificationRequest;

NotificationRequest.prototype.setPriority = function (priority) {
    if( priority >= -2 && priority <= 2){
        this.priority = priority;
    }
    return this.priority;
};

NotificationRequest.prototype.toHeaders = function () {
    var headers = new Headers();
    var header = new Header();
    headers.addHeader(new Header(HeaderEnum.applicationName,this.applicationName));
    headers.addHeader(new Header(HeaderEnum.notificationName,this.name));
    if( this.id !== null ) headers.addHeader(new Header(HeaderEnum.notificationId,this.id));
    headers.addHeader(new Header(HeaderEnum.notificationTitle,this.title));
    if( this.text !== null ) headers.addHeader(new Header(HeaderEnum.notificationText,this.text));
    headers.addHeader(new Header(HeaderEnum.notificationSticky,this.sticky));
    headers.addHeader(new Header(HeaderEnum.notificationPriority,this.priority));
    if( this.icon !== null ) headers.addHeader(new Header(HeaderEnum.notificationIcon,this.icon));
    if( this.callbackContext.length > 0 && this.callbackContextType.length > 0 ){
        headers.addHeader(new Header(HeaderEnum.notificationCallbackContext,this.callbackContext));
        headers.addHeader(new Header(HeaderEnum.notificationCallbackContextType,this.callbackContextType));
    }
    if( this.callbackTarget.length > 0 && this.callbackContext.length === 0 ){
        headers.addHeader(new Header(HeaderEnum.notificationCallbackTarget,this.callbackTarget));
    }
    return headers;
};

NotificationRequest.prototype.toRequest = function () {
    var req = new Message();
    req.type = this.type;
    req.headers.addHeaders(this.toHeaders());
    // crypto?
    return req;
};

/*-------------------------
    Message object
*/
function Message (mimeString) {
    this.type = MessageTypeEnum.UNKNOWN;
    this.headers = new Headers();
    this.crypto = null;
    
    if( typeof mimeString === 'string' ){
        this.parse(mimeString);
    }
}
exports.Message = Message;

Message.prototype.parse = function (mime){
    if ( !(mime instanceof Buffer) ){
        return undefined;
    }
    
    var len = mime.length,
        prev = 0, 
        curr = 0, 
        lines = 0, 
        sections = 0,
        blanks = 0,
        work,
        line,
        lineEnd,
        gap,
        protocol,
        security,
        resource = false,
        block,
        header =  new Header(); // i need to fix this object...
        
    var findEndSection = function (buff,start){
        if( buff instanceof Buffer){
            if( buff.length >= 4 &&
                start < buff.length){
                for( var i=start; i < buff.length -4; i++ ){
                    if( buff[i+0] == 13 && buff[i+1] == 10 &&
                        buff[i+2] == 13 && buff[i+3] == 10 ){
                        //End!
                        return i;
                    }
                }
            }
        }
        return -1;
    };
    
    var findEndLine = function (buff){
        if( ( buff instanceof Buffer ) && buff.length >= 2){
            for( var i=0; i < buff.length -2; i++ ){
                if( buff[i+0] == 13 && buff[i+1] == 10 ){
                    //End!
                    return i;
                }
            }
        }
        return -1;
    };
    
    while(curr < len && curr > -1 && blanks < 2){
        curr = findEndSection(mime,prev);
        if( curr > -1 ){
            sections++;
            work = mime.slice(prev,curr);
            
            // GNTP protocol header & headers (which may be encrypted)
            if( sections == 1 ){
                lineEnd = findEndLine(work,0);
                line = work.slice(0,lineEnd).toString('utf8');
                gap = line.indexOf(' ');
                protocol = line.substring(0,gap).split('/');
                if( protocol[0] != Protocol.name || protocol[1] != Protocol.version ){
                    console.log('bad protocol/version');
                    return;
                }
                this.type = line.substring(gap+1,line.indexOf(' ',gap+1));
                console.log('message type: ' + this.type + ' => ' + (this.type.substr(0,1) === '-'?'response':'request'));
                // check for the password & encryption
                security = line.substring(line.indexOf(' ',gap+1)+1);
                gap = security.indexOf(' ');
                //TODO: dont hardset the password..
                this.crypto = new Crypto('nodejs','sha1');
                if( gap > -1 ){
                    security = security.split(' ');
                    if( security[0] !== 'NONE' ){
                        security[0] = security[0].split(':');
                        this.crypto.useEncryption = true;
                        this.crypto.encryptAlg = security[0][0].toLowerCase();
                        this.crypto.iv = new Buffer(security[0][1].length/2);
                        this.crypto.iv.writeHex(security[0][1]);
                    }
                    security[1] = security[1].split(':');
                    this.crypto.hashAlg = security[1][0].toLowerCase();
                    security[1][1] = security[1][1].split('.');
                    if( !this.crypto.setKeyString(security[1][1][0],security[1][1][1]) ){
                        throw 'bad authentication';
                    }
                    
                }else{
                    this.crypto.password = '';
                }
                block = new Buffer(work.slice(lineEnd+2).length);
                work.slice(lineEnd+2).copy(block,0,0);
                
                if( this.crypto.useEncryption ){
                    // decrypt the block first.
                    block = this.crypto.decryptBuffer(block);
                }
                
                // process the headers
                console.log('Headers:\n'+block.toString('utf8'));
                
            }else{
                if( line === '' ){
                    // blanks
                    blanks++;
                    if( this.headers.length > 0) this.headers.addHeader(new Header(null,null));
                }else{
                    blanks = 0; // reset blanks, since we're counting *consecutive*
                    var parts = [ line.substring(0,line.indexOf(':')), line.substring(line.indexOf(':')+2)];
                    //console.log('header: ' + parts[0]);
                    var h = new Header(parts[0],parts[1]);
                    // check if it is a resource pointer, or anything as such. 
                    
                    // finally, add the header
                    this.headers.addHeader(h);
                }
            }
            prev = curr+4;
        }
    }
};

Message.prototype.protocolString = function (){
    var buffer = '';
    // replace NONE with the value of the crypto type.
    var securityString = 'NONE';
    if( this.crypto instanceof Crypto){
        securityString = this.crypto.getSecurityString();
    }
    buffer = buffer.concat(Protocol.name,'/',Protocol.version,' ',this.type,' ',securityString,EndLine);
    return buffer;
};

Message.prototype.mime = function () {
    
    // go through headers, section by section and type by type.
    var headerBuffer = '';
    var h;
    // headers
    for( h in this.headers.headers ){
        if( !this.headers.headers[h].isBlank ){
            headerBuffer = headerBuffer.concat(this.headers.headers[h].name,': ',this.headers.headers[h].value,EndLine);
        }else{
            headerBuffer = headerBuffer.concat(EndLine);
        }
    }
    // customHeaders
    for( h in this.headers.customHeaders ){
        if( !this.headers.customHeaders[h].isBlank ){
            headerBuffer = headerBuffer.concat(this.headers.customHeaders[h].name,': ',this.headers.customHeaders[h].value,EndLine);
        } // Blank not allowed in custom headers
    }
    // dataHeaders - will generate sections
    for( h in this.headers.dataHeaders ){
        // data headers not supported yet
    }
    // resourceHeaders - will generate sections
    for( h in this.headers.pointerHeaders ){
        // resource headers not supported yet.
    }
    
    // convert the utf8 text into a Buffer
    var bBuff = new Buffer(headerBuffer);
    
    //  If this message is supposed to be encrypted, encrypt the buffer
    //  - the response is a buffer object of the appropriate size, a replacement
    if( this.crypto instanceof Crypto && this.crypto.useEncryption){
        bBuff = this.crypto.encryptBuffer(bBuff);
    }
    
    return bBuff;
};

/*--------------------------
    Client object/class
*/
var net = require('net');
function Client () {
    this.host = '127.0.0.1';
    this.port = 23053;
    this.password = '';
    this.debug = false;
}
exports.Client = Client;
var fs = require('fs');
Client.prototype.sendMessage = function (request,reponseCallback){
    var response;
    var sock = net.createConnection(this.port,this.host);
    sock.on('connect',function () {
        var protocol = request.protocolString();
        var mime = request.mime();
        //console.log('protocol:'+protocol);
        //console.log('mesg:'+mime.toHex());
        //fs.writeFileSync('encrypt.log',mime);
        
        sock.write(protocol,'utf8'); //string
        sock.write(mime); // buffer
        sock.write(EndLine+EndLine+EndLine,'utf8'); // end of message
    });
    sock.on('data',function (data){
        console.log(data.toString());
        //var response = new Message(data.toString('utf8'));
        //if( typeof reponseCallback === 'function' ){
        //    reponseCallback(response);
        //}
    });
    sock.on('error',function (exception) { 
        console.log("socket error:"+exception); 
    });
    sock.on('close',function (had_error) { 
        console.log('socket closed.'+(had_error?' with eror':''));
    });
    sock.on('timeout',function () { 
        console.log('socket timeout'); 
        sock.end(); 
    });
    
};

/*--------------------
    Crypto class/object
    provides password and encryption capabilities.
*/
var rbytes = require('rbytes');
var crypt = require('crypto');
function Crypto(password,hash,encrypt){
    this.password = password || '';
    this.hashAlg = hash || 'sha256';
    this.encryptAlg = encrypt || 'AES';
    
    this.salt = rbytes.randomBytes(16);
    this.iv =  rbytes.randomBytes(16);
    
    this.useEncryption = (encrypt?true:false);
}
exports.Crypto = Crypto;

Crypto.prototype.setKeyString = function (keyHash,saltHex){
    this.salt = new Buffer(saltHex.length/2);
    this.salt.writeHex(saltHex);
    var key = this.getKeyString();
    return (key === keyHash);
};

Crypto.prototype.getKeyString = function (){
    // this will cause WHACKY behavior without a password set.
    var passwordBuffer = new Buffer(this.password);
    var keyBasis = new Buffer(passwordBuffer.length+this.salt.length);
    passwordBuffer.copy(keyBasis,0,0);
    this.salt.copy(keyBasis,passwordBuffer.length,0);
    var key = crypt.createHash(this.hashAlg).update(keyBasis).digest('hex');
    this.key = new Buffer(key.length/2);
    this.key.writeHex(key);
    var keyHash = crypt.createHash(this.hashAlg).update(crypt.createHash(this.hashAlg).update(keyBasis).digest()).digest('hex').toUpperCase();
    return keyHash;
};

Crypto.prototype.getSecurityString = function (){
    var security = 'NONE';
    if( this.password !== ''){
        if( this.useEncryption ){
            var ivLen = 8;
            if( this.encryptAlg.toUpperCase() === 'AES') { alg = 'aes192'; ivLen = 16; }
            if( this.encryptAlg.toUpperCase() === 'DES') keyLen = 8;
            if( this.encryptAlg.toUpperCase() === '3DES') alg = 'des3';
            security = this.encryptAlg.toUpperCase()+':'+this.iv.toHex().toUpperCase().substr(0,ivLen*2)+' ';
        }
        security += this.hashAlg.toUpperCase()+':'+this.getKeyString()+'.'+this.salt.toHex().toUpperCase();
    }
    return security;
};

Crypto.prototype.encryptBuffer = function (mime) {
    this.getKeyString();
    var keyB = this.key;
    var alg = this.encryptAlg;
    var keyLen = 24;
    var ivLen = 8;
    if( this.encryptAlg.toUpperCase() === 'AES') { alg = 'aes192'; ivLen = 16; }
    if( this.encryptAlg.toUpperCase() === 'DES') { alg = 'des'; keyLen = 8; }
    if( this.encryptAlg.toUpperCase() === '3DES') { alg = 'des3'; }
    var crypto = new crypt.createCipheriv(alg,keyB.toString('binary').substr(0,keyLen),this.iv.toString('binary').substr(0,ivLen));
    
    var ret = crypto.update(mime,null,'hex');
    var fin = crypto.final('hex');
    ret+=fin;
    
    var retBuff= new Buffer(ret.length/2);
    retBuff.writeHex(ret);
    
    return retBuff;
};

Crypto.prototype.decryptBuffer = function (mime) {
    this.getKeyString();
    var keyB = this.key;
    var alg = this.encryptAlg;
    var keyLen = 24;
    var ivLen = 8;
    if( this.encryptAlg.toUpperCase() === 'AES') { alg = 'aes192'; ivLen = 16; }
    if( this.encryptAlg.toUpperCase() === 'DES') { alg = 'des'; keyLen = 8; }
    if( this.encryptAlg.toUpperCase() === '3DES') { alg = 'des3'; }
    var crypto = new crypt.createDecipheriv(alg,keyB.toString('binary').substr(0,keyLen),this.iv.toString('binary').substr(0,ivLen));
    
    var ret = crypto.update(mime,null,'binary');
    var fin = crypto.final('binary');
    ret+=fin;
    
    var retBuff= new Buffer(ret,'binary');
    
    return retBuff;
};